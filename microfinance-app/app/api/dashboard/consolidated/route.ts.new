import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getCurrentUserId } from '@/lib/auth';
import { generatePaymentSchedule, calculateNextPaymentDate, updateOverdueAmountFromRepayments } from '@/lib/paymentSchedule';
import * as XLSX from 'xlsx';

// Use ISR with a 5-minute revalidation period
export const revalidate = 300; // 5 minutes

// Use type assertion to handle TypeScript type checking
const prismaAny = prisma as any;

// Main route handler
export async function GET(request: NextRequest) {
  try {
    const timerLabel = `dashboard-api-${Date.now()}`;
    console.time(timerLabel); // Add timing with unique label

    // Get the current user ID
    const currentUserId = await getCurrentUserId();
    if (!currentUserId) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Get the action from the query string
    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');

    // Route to the appropriate handler based on the action
    switch (action) {
      case 'summary':
        return await getSummary(request, currentUserId);
      case 'financial-data':
        return await getFinancialData(request, currentUserId);
      case 'events':
        // Get the view parameter
        const view = searchParams.get('view');

        // For dashboard view, get upcoming events
        if (view === 'dashboard') {
          const limit = searchParams.get('limit') ? parseInt(searchParams.get('limit') as string, 10) : 3;
          const dashboardEvents = await getUpcomingEventsForDashboard(currentUserId, limit);

          // Count total upcoming events for the next 3 months
          const totalCount = await countUpcomingEvents(currentUserId);

          // Return dashboard events with count
          return NextResponse.json({
            events: dashboardEvents,
            totalCount
          });
        }

        // For calendar view, get events for the specified month
        if (view === 'calendar') {
          const year = parseInt(searchParams.get('year') || new Date().getFullYear().toString(), 10);
          const month = parseInt(searchParams.get('month') || (new Date().getMonth() + 1).toString(), 10);
          const calendarEvents = await getEventsForMonth(currentUserId, year, month);
          return NextResponse.json(calendarEvents);
        }

        // Default to upcoming events for dashboard
        const upcomingEvents = await getUpcomingEventsForDashboard(currentUserId);
        return NextResponse.json(upcomingEvents);
      default:
        return NextResponse.json(
          { error: 'Invalid action' },
          { status: 400 }
        );
    }
  } catch (error) {
    console.error('Error in dashboard API:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// Helper function to get dashboard summary
async function getSummary(request: NextRequest, currentUserId: number) {
  try {
    const timerLabel = `getSummary-${Date.now()}`;
    console.time(timerLabel); // Add timing with unique label

    // Get all data in parallel for better performance
    const [
      // Get total cash inflow from chit fund contributions
      contributionsSum,
      // Get total cash outflow from auctions
      auctionsSum,
      // Get total cash inflow from loan repayments
      repaymentsSum,
      // Get total cash outflow from loans
      loansSum,
      // Get total document charges from loans
      documentChargesSum,
      // Get recent activities and upcoming events in parallel
      activitiesAndEventsPromise,
      // Optimize chit fund query to only fetch what's needed
      chitFundsWithData
    ] = await Promise.all([
      // Get total cash inflow from chit fund contributions
      prisma.contribution.aggregate({
        _sum: { amount: true },
        where: {
          chitFund: {
            createdById: currentUserId
          }
        }
      }),

      // Get total cash outflow from auctions
      prisma.auction.aggregate({
        _sum: { amount: true },
        where: {
          chitFund: {
            createdById: currentUserId
          }
        }
      }),

      // Get total cash inflow from loan repayments
      prisma.repayment.aggregate({
        _sum: { amount: true },
        where: {
          loan: {
            createdById: currentUserId
          }
        }
      }),

      // Get total cash outflow from loans
      prisma.loan.aggregate({
        _sum: { amount: true },
        where: {
          createdById: currentUserId
        }
      }),

      // Get total document charges from loans
      prisma.loan.aggregate({
        _sum: { documentCharge: true },
        where: {
          createdById: currentUserId
        }
      }),

      // Get recent activities and upcoming events in parallel
      Promise.all([
        getRecentActivitiesData(currentUserId),
        getUpcomingEventsForDashboard(currentUserId)
      ]),

      // Get chit funds with their contributions and auctions
      prisma.chitFund.findMany({
        where: {
          createdById: currentUserId
        },
        select: {
          id: true,
          name: true,
          amount: true,
          duration: true,
          currentMonth: true,
          status: true,
          _count: {
            select: {
              members: true,
              auctions: true,
              contributions: true
            }
          }
        }
      })
    ]);

    // Extract values from the aggregations
    const cashInflow = (contributionsSum._sum.amount || 0) + (repaymentsSum._sum.amount || 0);
    const cashOutflow = (auctionsSum._sum.amount || 0) + (loansSum._sum.amount || 0);
    const documentCharges = documentChargesSum._sum.documentCharge || 0;

    // Calculate profits
    const loanProfit = (repaymentsSum._sum.amount || 0) - (loansSum._sum.amount || 0) + documentCharges;
    const chitFundProfit = (contributionsSum._sum.amount || 0) - (auctionsSum._sum.amount || 0);
    const totalProfit = loanProfit + chitFundProfit;

    // Calculate outside amount (when cash outflow exceeds inflow)
    const outsideAmount = cashOutflow > cashInflow ? cashOutflow - cashInflow : 0;

    // Get recent activities and upcoming events
    const [recentActivities, upcomingEvents] = await activitiesAndEventsPromise;

    // Get total upcoming events count
    const totalUpcomingEvents = await countUpcomingEvents(currentUserId);

    console.timeEnd(timerLabel); // End timing with the same unique label

    // Return the dashboard summary
    return NextResponse.json({
      cashInflow,
      cashOutflow,
      outsideAmount,
      profit: {
        total: totalProfit,
        loans: loanProfit,
        chitFunds: chitFundProfit
      },
      counts: {
        chitFunds: chitFundsWithData.length,
        activeChitFunds: chitFundsWithData.filter(cf => cf.status === 'Active').length,
        members: chitFundsWithData.reduce((sum, cf) => sum + cf._count.members, 0),
        loans: await prisma.loan.count({ where: { createdById: currentUserId } }),
        activeLoans: await prisma.loan.count({ where: { createdById: currentUserId, status: 'Active' } })
      },
      recentActivities,
      upcomingEvents,
      totalUpcomingEvents
    });
  } catch (error) {
    console.error('Error fetching dashboard summary:', error);
    return NextResponse.json(
      { error: 'Failed to fetch dashboard summary' },
      { status: 500 }
    );
  }
}

// Helper function to get financial data for charts
async function getFinancialData(request: NextRequest, currentUserId: number) {
  try {
    const timerLabel = `getFinancialData-${Date.now()}`;
    console.time(timerLabel);

    // Get duration and limit from query params
    const { searchParams } = new URL(request.url);
    const duration = searchParams.get('duration') || 'monthly';
    const limit = parseInt(searchParams.get('limit') || '12', 10);

    // Calculate date range based on duration
    const endDate = new Date();
    let startDate = new Date();

    if (duration === 'monthly') {
      startDate.setMonth(endDate.getMonth() - limit + 1);
      startDate.setDate(1);
    } else if (duration === 'yearly') {
      startDate.setFullYear(endDate.getFullYear() - limit + 1);
      startDate.setMonth(0);
      startDate.setDate(1);
    } else if (duration === 'weekly') {
      startDate.setDate(endDate.getDate() - (limit * 7) + 1);
    }

    startDate.setHours(0, 0, 0, 0);
    endDate.setHours(23, 59, 59, 999);

    // Fetch all data in parallel
    const [allContributions, allRepayments, allAuctions, allLoans] = await Promise.all([
      // Get all contributions for the entire date range
      prisma.contribution.findMany({
        where: {
          chitFund: {
            createdById: currentUserId
          },
          paidDate: {
            gte: startDate,
            lte: endDate
          }
        },
        select: {
          amount: true,
          paidDate: true
        },
        orderBy: {
          paidDate: 'asc'
        }
      }),

      // Get all repayments for the entire date range
      prisma.repayment.findMany({
        where: {
          loan: {
            createdById: currentUserId
          },
          paidDate: {
            gte: startDate,
            lte: endDate
          }
        },
        select: {
          amount: true,
          paidDate: true,
          paymentType: true
        },
        orderBy: {
          paidDate: 'asc'
        }
      }),

      // Get all auctions for the entire date range
      prisma.auction.findMany({
        where: {
          chitFund: {
            createdById: currentUserId
          },
          date: {
            gte: startDate,
            lte: endDate
          }
        },
        select: {
          amount: true,
          date: true
        },
        orderBy: {
          date: 'asc'
        }
      }),

      // Get all loans for the entire date range
      prisma.loan.findMany({
        where: {
          createdById: currentUserId,
          disbursementDate: {
            gte: startDate,
            lte: endDate
          }
        },
        select: {
          amount: true,
          documentCharge: true,
          disbursementDate: true
        },
        orderBy: {
          disbursementDate: 'asc'
        }
      })
    ]);

    // Generate periods based on duration
    const periods = [];
    const periodData = {
      cashInflow: [],
      cashOutflow: [],
      profit: [],
      outsideAmount: []
    };

    // Helper function to format period label
    const formatPeriodLabel = (date: Date) => {
      if (duration === 'monthly') {
        return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
      } else if (duration === 'yearly') {
        return date.getFullYear().toString();
      } else if (duration === 'weekly') {
        return `Week ${Math.ceil(date.getDate() / 7)} ${date.toLocaleDateString('en-US', { month: 'short' })}`;
      }
      return '';
    };

    // Helper function to check if a date falls within a period
    const isInPeriod = (date: Date, periodStart: Date, periodEnd: Date) => {
      return date >= periodStart && date <= periodEnd;
    };

    // Generate periods and calculate data for each period
    let currentDate = new Date(startDate);
    for (let i = 0; i < limit; i++) {
      let periodStart = new Date(currentDate);
      let periodEnd = new Date(currentDate);

      if (duration === 'monthly') {
        periodEnd.setMonth(periodStart.getMonth() + 1);
        periodEnd.setDate(0); // Last day of the month
        periodEnd.setHours(23, 59, 59, 999);
      } else if (duration === 'yearly') {
        periodEnd.setFullYear(periodStart.getFullYear() + 1);
        periodEnd.setMonth(0);
        periodEnd.setDate(0); // Last day of December
        periodEnd.setHours(23, 59, 59, 999);
      } else if (duration === 'weekly') {
        periodEnd.setDate(periodStart.getDate() + 6);
        periodEnd.setHours(23, 59, 59, 999);
      }

      // Calculate financial data for this period
      const periodContributions = allContributions.filter(c =>
        isInPeriod(new Date(c.paidDate), periodStart, periodEnd)
      ).reduce((sum, c) => sum + c.amount, 0);

      const periodRepayments = allRepayments.filter(r =>
        isInPeriod(new Date(r.paidDate), periodStart, periodEnd)
      ).reduce((sum, r) => sum + r.amount, 0);

      const periodAuctions = allAuctions.filter(a =>
        isInPeriod(new Date(a.date), periodStart, periodEnd)
      ).reduce((sum, a) => sum + a.amount, 0);

      const periodLoans = allLoans.filter(l =>
        isInPeriod(new Date(l.disbursementDate), periodStart, periodEnd)
      );

      const periodLoanAmount = periodLoans.reduce((sum, l) => sum + l.amount, 0);
      const periodDocumentCharges = periodLoans.reduce((sum, l) => sum + (l.documentCharge || 0), 0);

      // Calculate totals for the period
      const periodCashInflow = periodContributions + periodRepayments;
      const periodCashOutflow = periodAuctions + periodLoanAmount;
      const periodProfit = (periodRepayments - periodLoanAmount + periodDocumentCharges) +
                          (periodContributions - periodAuctions);
      const periodOutsideAmount = periodCashOutflow > periodCashInflow ?
                                periodCashOutflow - periodCashInflow : 0;

      // Add period data
      periods.push(formatPeriodLabel(periodStart));
      periodData.cashInflow.push(periodCashInflow);
      periodData.cashOutflow.push(periodCashOutflow);
      periodData.profit.push(periodProfit);
      periodData.outsideAmount.push(periodOutsideAmount);

      // Move to next period
      if (duration === 'monthly') {
        currentDate.setMonth(currentDate.getMonth() + 1);
      } else if (duration === 'yearly') {
        currentDate.setFullYear(currentDate.getFullYear() + 1);
      } else if (duration === 'weekly') {
        currentDate.setDate(currentDate.getDate() + 7);
      }
    }

    console.timeEnd(timerLabel);

    return NextResponse.json({
      periods,
      data: periodData
    });
  } catch (error) {
    console.error('Error fetching financial data:', error);
    return NextResponse.json(
      { error: 'Failed to fetch financial data' },
      { status: 500 }
    );
  }
}

// Helper function to get recent activities
async function getRecentActivitiesData(userId: number) {
  try {
    const timerLabel = `getRecentActivitiesData-${Date.now()}`;
    console.time(timerLabel); // Add timing with unique label

    // Get all recent activities in parallel with optimized queries
    const [recentMembers, recentAuctions, recentLoans, recentRepayments] = await Promise.all([
      // Get recent members (new chit fund members) with optimized select
      prisma.member.findMany({
        take: 3,
        where: {
          chitFund: {
            createdById: userId
          }
        },
        orderBy: {
          joinDate: 'desc',
        },
        select: {
          id: true,
          joinDate: true,
          chitFund: {
            select: {
              name: true,
            }
          },
          globalMember: {
            select: {
              name: true,
            }
          },
        },
      }),

      // Get recent auctions with optimized select
      prisma.auction.findMany({
        take: 3,
        where: {
          chitFund: {
            createdById: userId
          }
        },
        orderBy: {
          date: 'desc',
        },
        select: {
          id: true,
          amount: true,
          date: true,
          chitFund: {
            select: {
              name: true,
            }
          },
          winner: {
            select: {
              globalMember: {
                select: {
                  name: true,
                }
              }
            }
          },
        },
      }),

      // Get recent loans with optimized select
      prisma.loan.findMany({
        take: 3,
        where: {
          createdById: userId
        },
        orderBy: {
          createdAt: 'desc',
        },
        select: {
          id: true,
          amount: true,
          loanType: true,
          disbursementDate: true,
          borrower: {
            select: {
              name: true,
            }
          },
        },
      }),

      // Get recent repayments with optimized select
      prisma.repayment.findMany({
        take: 3,
        where: {
          loan: {
            createdById: userId
          }
        },
        orderBy: {
          paidDate: 'desc',
        },
        select: {
          id: true,
          amount: true,
          paidDate: true,
          loan: {
            select: {
              borrower: {
                select: {
                  name: true,
                }
              }
            }
          },
        },
      }),
    ]);

    // Combine and format all activities
    const activities = [
      ...recentMembers.map((member: any) => {
        // Get member name and chit fund name safely
        const memberName = member.globalMember ? member.globalMember.name : 'Unknown Member';
        const chitFundName = member.chitFund ? member.chitFund.name : 'Unknown Chit Fund';

        return {
          id: `member-${member.id}`,
          type: 'Chit Fund',
          action: 'New member joined',
          details: `${memberName} joined ${chitFundName}`,
          date: member.joinDate,
        };
      }),
      ...recentAuctions.map((auction: any) => {
        // Get winner name safely, handling potential undefined values
        const winnerName = auction.winner && auction.winner.globalMember
          ? auction.winner.globalMember.name
          : 'Unknown Member';

        return {
          id: `auction-${auction.id}`,
          type: 'Chit Fund',
          action: 'Auction completed',
          details: `${auction.chitFund.name} auction won by ${winnerName} at ₹${auction.amount}`,
          date: auction.date,
        };
      }),
      ...recentLoans.map((loan: any) => {
        // Get borrower name safely
        const borrowerName = loan.borrower ? loan.borrower.name : 'Unknown Borrower';

        return {
          id: `loan-${loan.id}`,
          type: 'Loan',
          action: 'Loan approved',
          details: `${loan.loanType} loan of ₹${loan.amount} approved for ${borrowerName}`,
          date: loan.disbursementDate,
        };
      }),
      ...recentRepayments.map((repayment: any) => {
        // Get borrower name safely with nested null checks
        const borrowerName = repayment.loan && repayment.loan.borrower
          ? repayment.loan.borrower.name
          : 'Unknown Borrower';

        return {
          id: `repayment-${repayment.id}`,
          type: 'Loan',
          action: 'Repayment received',
          details: `Loan repayment of ₹${repayment.amount} received from ${borrowerName}`,
          date: repayment.paidDate,
        };
      }),
    ];

    // Sort by date (newest first) and take top 5
    const result = activities
      .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
      .slice(0, 5)
      .map(activity => ({
        ...activity,
        date: formatRelativeTime(activity.date),
      }));

    console.timeEnd(timerLabel); // End timing with the same unique label
    return result;
  } catch (error) {
    console.error('Error getting recent activities:', error);
    return [];
  }
}

// Helper function to get upcoming events for the dashboard (limited to a few)
async function getUpcomingEventsForDashboard(userId: number, limit: number = 3) {
  try {
    const timerLabel = `getUpcomingEventsForDashboard-${Date.now()}`;
    console.time(timerLabel);

    const today = new Date();
    today.setHours(0, 0, 0, 0); // Set to beginning of day for accurate comparisons

    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    // For dashboard, we only need events for the next 3 months
    const nextThreeMonths = new Date();
    nextThreeMonths.setMonth(today.getMonth() + 3);

    console.log(`Fetching upcoming events from ${today.toISOString()} to ${nextThreeMonths.toISOString()}`);

    // Get upcoming auctions and active loans in parallel
    const [upcomingAuctions, activeLoans] = await Promise.all([
      // Get upcoming auctions
      prisma.chitFund.findMany({
        where: {
          status: 'Active',
          createdById: userId,
          nextAuctionDate: {
            gte: today,
            lte: nextThreeMonths,
          },
        },
        select: {
          id: true,
          name: true,
          nextAuctionDate: true,
        },
        orderBy: {
          nextAuctionDate: 'asc',
        },
      }),

      // Get all active loans to generate payment schedules
      prisma.loan.findMany({
        where: {
          status: 'Active',
          createdById: userId,
        },
        select: {
          id: true,
          disbursementDate: true,
          duration: true,
          repaymentType: true,
          installmentAmount: true,
          borrower: {
            select: {
              id: true,
              name: true
            }
          },
          repayments: {
            select: {
              id: true,
              period: true,
              paidDate: true,
              paymentType: true
            }
          }
        }
      })
    ]);

    // Initialize events array with auctions
    const events = [
      ...upcomingAuctions.map((auction: any) => {
        // Check if auction is due tomorrow
        const auctionDate = auction.nextAuctionDate ? new Date(auction.nextAuctionDate) : null;
        let isDueTomorrow = false;

        if (auctionDate) {
          auctionDate.setHours(0, 0, 0, 0); // Set to beginning of day
          isDueTomorrow = auctionDate.getTime() === tomorrow.getTime();
        }

        return {
          id: `auction-${auction.id}`,
          title: `${auction.name} Auction`,
          date: auction.nextAuctionDate ? formatDate(auction.nextAuctionDate) : 'Date not set',
          type: 'Chit Fund',
          isDueTomorrow: isDueTomorrow,
          entityId: auction.id,
          entityType: 'chitFund'
        };
      }),
    ];

    console.log(`Found ${upcomingAuctions.length} upcoming auctions`);
    console.log(`Processing ${activeLoans.length} active loans for payment schedules`);

    // Process each active loan to generate payment schedules
    for (const loan of activeLoans) {
      // Use type assertion to access properties safely
      const loanAny = loan as any;

      const loanId = loanAny.id;
      const disbursementDate = new Date(loanAny.disbursementDate);
      const duration = loanAny.duration;
      const repaymentType = loanAny.repaymentType;
      const installmentAmount = loanAny.installmentAmount;

      // Get borrower name safely
      const borrowerName = loanAny.borrower && loanAny.borrower.name
        ? loanAny.borrower.name
        : 'Unknown Borrower';

      // Create a map of repayments by period for quick lookup
      const repaymentsByPeriod = new Map();
      if (loanAny.repayments && Array.isArray(loanAny.repayments)) {
        loanAny.repayments.forEach((repayment: any) => {
          if (repayment && repayment.period) {
            repaymentsByPeriod.set(repayment.period, repayment);
          }
        });
      }

      // Generate all possible periods and their due dates
      for (let period = 1; period <= duration; period++) {
        const dueDate = new Date(disbursementDate);

        if (repaymentType === 'Monthly') {
          dueDate.setMonth(disbursementDate.getMonth() + period);
        } else if (repaymentType === 'Weekly') {
          dueDate.setDate(disbursementDate.getDate() + (period * 7));
        }

        // Check if this period has been paid
        const repayment = repaymentsByPeriod.get(period);
        const isPaid = !!repayment && repayment.paidDate;

        // Only add unpaid schedules that are in the date range
        if (!isPaid && dueDate >= today && dueDate <= nextThreeMonths) {
          const dueDateNormalized = new Date(dueDate);
          dueDateNormalized.setHours(0, 0, 0, 0);
          const isDueTomorrow = dueDateNormalized.getTime() === tomorrow.getTime();

          // Create event object
          const eventObj: any = {
            id: `schedule-${loanId}-${period}`,
            title: `${borrowerName} Loan Payment (Period ${period})`,
            date: formatDate(dueDate),
            type: 'Loan',
            isDueTomorrow: isDueTomorrow,
            entityId: loanId,
            entityType: 'loan',
            rawDate: dueDate
          };

          // Add optional properties
          if (loanAny.borrower && loanAny.borrower.id) {
            eventObj.borrowerId = loanAny.borrower.id;
          }

          eventObj.period = period;

          events.push(eventObj);
        }
      }
    }

    // Sort by date (soonest first) and limit to requested number
    events.sort((a, b) => {
      // Use type assertion to access rawDate property
      const aAny = a as any;
      const bAny = b as any;

      // Use rawDate if available, otherwise parse the formatted date
      const dateA = aAny.rawDate ? new Date(aAny.rawDate).getTime() :
                   new Date(a.date.replace(/(\d+)\s+([A-Za-z]+)\s+(\d+)/, '$3-$2-$1')).getTime();
      const dateB = bAny.rawDate ? new Date(bAny.rawDate).getTime() :
                   new Date(b.date.replace(/(\d+)\s+([A-Za-z]+)\s+(\d+)/, '$3-$2-$1')).getTime();
      return dateA - dateB;
    });

    // Take only the requested number of events
    const limitedEvents = events.slice(0, limit);

    // Log the events we're returning
    console.log('Dashboard events (sorted by date):', limitedEvents.map(e => ({
      title: e.title,
      date: e.date,
      isDueTomorrow: e.isDueTomorrow
    })));

    console.timeEnd(timerLabel);
    return limitedEvents;
  } catch (error) {
    console.error('Error getting upcoming events for dashboard:', error);
    return [];
  }
}

// Helper function to count total upcoming events for the next 3 months
async function countUpcomingEvents(userId: number) {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const nextThreeMonths = new Date();
    nextThreeMonths.setMonth(today.getMonth() + 3);

    // Count upcoming auctions
    const auctionCount = await prisma.chitFund.count({
      where: {
        status: 'Active',
        createdById: userId,
        nextAuctionDate: {
          gte: today,
          lte: nextThreeMonths,
        },
      },
    });

    // Count active loans with upcoming payments
    const loanCount = await prisma.loan.count({
      where: {
        status: 'Active',
        createdById: userId,
        nextPaymentDate: {
          gte: today,
          lte: nextThreeMonths,
        },
      },
    });

    // Return the total count
    return auctionCount + loanCount;
  } catch (error) {
    console.error('Error counting upcoming events:', error);
    return 0;
  }
}

// Helper function to get events for a specific month
async function getEventsForMonth(userId: number, year: number, month: number) {
  try {
    const timerLabel = `getEventsForMonth-${year}-${month}-${Date.now()}`;
    console.time(timerLabel);

    // Create a date range for the specified month
    console.log(`Filtering events for year: ${year}, month: ${month}`);

    // Create start date (first day of the specified month)
    const startDate = new Date(year, month - 1, 1); // Month is 0-indexed in JavaScript Date

    // Create end date (last day of the specified month)
    const endDate = new Date(year, month, 0); // Day 0 of next month = last day of current month
    endDate.setHours(23, 59, 59, 999);

    console.log(`Date range: ${startDate.toISOString()} to ${endDate.toISOString()}`);

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    // Log the date range for debugging
    console.log('Fetching events for date range:', {
      startDate: startDate.toISOString(),
      endDate: endDate.toISOString(),
      year,
      month
    });

    // Get auctions and active loans in parallel for the specified month
    const [monthAuctions, activeLoans] = await Promise.all([
      // Get auctions for the month
      prisma.chitFund.findMany({
        where: {
          status: 'Active',
          createdById: userId,
          nextAuctionDate: {
            gte: startDate,
            lte: endDate,
          },
        },
        select: {
          id: true,
          name: true,
          nextAuctionDate: true,
        },
        orderBy: {
          nextAuctionDate: 'asc',
        },
      }),

      // Get all active loans to check their payment schedules
      prisma.loan.findMany({
        where: {
          status: 'Active',
          createdById: userId,
        },
        select: {
          id: true,
          disbursementDate: true,
          duration: true,
          repaymentType: true,
          borrower: {
            select: {
              id: true,
              name: true
            }
          },
          repayments: {
            select: {
              period: true,
              paidDate: true
            }
          }
        }
      })
    ]);

    // Log the results for debugging
    console.log('Found auctions:', monthAuctions.length);
    console.log('Found active loans:', activeLoans.length);

    // Initialize events array with auctions
    const events = [
      ...monthAuctions.map((auction: any) => {
        // Check if auction is due tomorrow
        const auctionDate = auction.nextAuctionDate ? new Date(auction.nextAuctionDate) : null;
        let isDueTomorrow = false;

        if (auctionDate) {
          const auctionDateNormalized = new Date(auctionDate);
          auctionDateNormalized.setHours(0, 0, 0, 0);
          isDueTomorrow = auctionDateNormalized.getTime() === tomorrow.getTime();
        }

        return {
          id: `auction-${auction.id}`,
          title: `${auction.name} Auction`,
          date: auction.nextAuctionDate ? formatDate(auction.nextAuctionDate) : 'Date not set',
          type: 'Chit Fund',
          rawDate: auction.nextAuctionDate,
          isDueTomorrow: isDueTomorrow,
          entityId: auction.id,
          entityType: 'chitFund'
        };
      }),
    ];

    // Process each active loan to check for payment schedules in this month
    for (const loan of activeLoans) {
      // Log loan details for debugging
      console.log('Processing loan:', {
        id: loan.id,
        disbursementDate: loan.disbursementDate,
        repaymentType: loan.repaymentType,
        duration: loan.duration,
        borrowerName: loan.borrower?.name
      });

      // Create a map of repayments by period for quick lookup
      const repaymentsByPeriod = new Map();
      loan.repayments.forEach((repayment: any) => {
        if (repayment.period) {
          repaymentsByPeriod.set(repayment.period, repayment);
        }
      });

      const disbursementDate = new Date(loan.disbursementDate);
      const repaymentType = loan.repaymentType;
      const duration = loan.duration;
      const borrowerName = loan.borrower ? loan.borrower.name : 'Unknown Borrower';
      const borrowerId = loan.borrower ? loan.borrower.id : null;

      // Generate schedules for each period
      for (let period = 1; period <= duration; period++) {
        // Calculate the due date for this period
        const dueDate = new Date(disbursementDate);
        if (repaymentType === 'Monthly') {
          dueDate.setMonth(disbursementDate.getMonth() + period);
        } else if (repaymentType === 'Weekly') {
          dueDate.setDate(disbursementDate.getDate() + (period * 7));
        }

        // Check if this period has been paid
        const repayment = repaymentsByPeriod.get(period);
        const isPaid = !!repayment && repayment.paidDate;

        // Check if the due date is in the specified month
        const isInMonth = dueDate >= startDate && dueDate <= endDate;

        // Log payment schedule details for debugging
        console.log(`Loan ${loan.id}, Period ${period}:`, {
          dueDate: dueDate.toISOString(),
          isPaid,
          isInMonth,
          startDate: startDate.toISOString(),
          endDate: endDate.toISOString(),
          repayment: repayment || 'none'
        });

        // Only add unpaid schedules that are in the specified month
        if (!isPaid && isInMonth) {
          const dueDateNormalized = new Date(dueDate);
          dueDateNormalized.setHours(0, 0, 0, 0);
          const isDueTomorrow = dueDateNormalized.getTime() === tomorrow.getTime();

          // Create event object with type assertion to allow additional properties
          const eventObj: any = {
            id: `schedule-${loan.id}-${period}`,
            title: `${borrowerName} Loan Payment (Period ${period})`,
            date: formatDate(dueDate),
            type: 'Loan',
            rawDate: dueDate,
            isDueTomorrow: isDueTomorrow,
            entityId: loan.id,
            entityType: 'loan'
          };

          // Add optional properties
          if (borrowerId) {
            eventObj.borrowerId = borrowerId;
          }

          eventObj.period = period;

          events.push(eventObj);
        }
      }
    }

    // Log all events before sorting
    console.log(`Total events found for ${year}-${month} before sorting:`, events.length);

    // Log date range again for clarity
    console.log(`Filtered events between ${startDate.toISOString()} and ${endDate.toISOString()}`);

    // Sort by date (soonest first)
    events.sort((a, b) => {
      if (!a.rawDate) return 1;
      if (!b.rawDate) return -1;
      return new Date(a.rawDate).getTime() - new Date(b.rawDate).getTime();
    });

    // Remove rawDate from the response
    const formattedEvents = events.map(({ rawDate, ...rest }) => rest);

    // Log final events
    console.log(`Final events for ${year}-${month} after processing:`, formattedEvents);

    console.timeEnd(timerLabel);
    return formattedEvents;
  } catch (error) {
    console.error('Error getting events for month:', error);
    return [];
  }
}

// Helper function to format relative time
function formatRelativeTime(date: Date | string): string {
  const now = new Date();
  const then = new Date(date);
  const diffInSeconds = Math.floor((now.getTime() - then.getTime()) / 1000);

  if (diffInSeconds < 60) {
    return 'just now';
  } else if (diffInSeconds < 3600) {
    const minutes = Math.floor(diffInSeconds / 60);
    return `${minutes} ${minutes === 1 ? 'minute' : 'minutes'} ago`;
  } else if (diffInSeconds < 86400) {
    const hours = Math.floor(diffInSeconds / 3600);
    return `${hours} ${hours === 1 ? 'hour' : 'hours'} ago`;
  } else if (diffInSeconds < 604800) {
    const days = Math.floor(diffInSeconds / 86400);
    return `${days} ${days === 1 ? 'day' : 'days'} ago`;
  } else {
    return formatDate(date);
  }
}

// Helper function to format date
function formatDate(date: Date | string): string {
  const options: Intl.DateTimeFormatOptions = {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  };
  return new Date(date).toLocaleDateString('en-IN', options);
}